/* Distributed under Mozilla Public Licence 2.0   */
/* https://www.mozilla.org/en-US/MPL/2.0/         */
/* 2015-09-22 (C) Jonas S Karlsson, jsk@yesco.org */
/* "test" driver for "unix"                       */
/* provides alt implementations to esplisp.c      */

#include <stdio.h>
#include <time.h>

#include "lisp.h"
#include "compat.h"

#include <unistd.h>
#include <fcntl.h>

// dummies
void gpio_enable(int pin, int state) {}
void gpio_write(int pin, int value) {}
int gpio_read(int pin) { return 0; }

unsigned int lastClock = 0;
int lastMem = 0;

// TODO: use this! mcheck, mcheck_check_all, mcheck_pedantic, mprobe - heap consistency checking
// http://www.gnu.org/software/libc/manual/html_node/Heap-Consistency-Checking.html#Heap-Consistency-Checking
// http://www.gnu.org/software/libc/manual/html_node/Hooks-for-Malloc.html#Hooks-for-Malloc
// http://www.gnu.org/software/libc/manual/html_node/Obstacks.html#Obstacks
// http://stackoverflow.com/questions/10472929/gettotalmemory-allocation-in-c
// http://stackoverflow.com/questions/910172/track-c-memory-allocations
void print_memory_info(int verbose) {
    report_allocs(verbose);

    int clk = clock();
    int ms = (int)((clk - lastClock) * 1000 / CLOCKS_PER_SEC);
    int mem = 0;
    if (verbose == 2) 
        printf("=== free=%u USED=%u bytes TIME=%d ms ===\n", mem, lastMem-mem, ms);
    else if (verbose == 1) {
        if (mem) printf("free=%u ", mem);
        if (lastMem-mem) printf("USED=%u bytes ", lastMem-mem);
        if (ms) printf("TIME=%d ms ", ms);
	printf("\n");
    }
    lastClock = clk;
    lastMem = mem;
}

int clock_ms() {
    static const int clocks_per_ms = CLOCKS_PER_SEC / 1000;
    return (int)(clock()) / clocks_per_ms;
}

void connect_wifi(char* ssid, char* password) { /* dummy */ }

// on linux, this is "non-blocking" as in it doesn't detect characters as typed
// but they are buffered, however, none are available until you press RETURN.

// http://cc.byexamples.com/2007/04/08/non-blocking-user-input-in-loop-without-ncurses/
// http://stackoverflow.com/questions/448944/c-non-blocking-keyboard-input

#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>
#include <termios.h>

int nonblock_getch() {
    static int first = 1;
    static struct termios orig_termios;
    if (first) {
        tcgetattr(0, &orig_termios);
	//atexit(reset_terminal_mode);
	first = 0;
    }

    struct termios new_termios;
    memcpy(&new_termios, &orig_termios, sizeof(new_termios));

    // essentially, make it raw
    cfmakeraw(&new_termios);
    new_termios.c_iflag &= ~ICRNL;
    new_termios.c_iflag &= ~IGNCR;
    new_termios.c_oflag |= OPOST;
    tcsetattr(0, TCSANOW, &new_termios);

    // kbdhit
    struct timeval tv = { 0L, 0L };
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(0, &fds);
    int r = 0;
    // read if have
    if (select(1, &fds, NULL, NULL, &tv)) {
        unsigned char c;
	if ((r = read(0, &c, sizeof(c))) > 0)
	    r = c;
    }

    // trap CTRL-C, clean exit
    if (r == 3) {
        tcsetattr(0, TCSANOW, &orig_termios);
	exit(0);
    }

    return r;
}

int main() {
    lastClock = clock();
    lastMem = 0;

    setbuf(stdin, NULL);
    setbuf(stdout, NULL);

    lisp env = lisp_init();
    lisp_run(&env);
}
